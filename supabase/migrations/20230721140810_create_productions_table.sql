create table "public"."productions" (
    "id" bigint generated by default as identity not null,
    "slug" text not null,
    "title" text not null,
    "plot" text,
    "release_date" date not null,
    "runtime" smallint,
    "tmdb_id" character varying not null,
    "imdb_id" character varying,
    "nbdb_id" character varying,
    "created_at" timestamp with time zone default now() not null,
    "created_by" uuid not null,
    "updated_at" timestamp with time zone default now(),
    "updated_by" uuid,
    "published" boolean default false not null
);

alter table "public"."productions"
    add constraint "productions_created_by_fkey"
    FOREIGN KEY (created_by)
    REFERENCES auth.users(id)
    ON DELETE SET NULL not valid;

alter table "public"."productions"
    validate constraint "productions_created_by_fkey";

alter table "public"."productions"
    add constraint "productions_updated_by_fkey"
    FOREIGN KEY (updated_by)
    REFERENCES auth.users(id)
    ON DELETE SET NULL not valid;

alter table "public"."productions"
    validate constraint "productions_updated_by_fkey";

alter table "public"."productions"
    alter column "created_by" set default auth.uid();


create or replace function set_updated_by()
returns trigger as $$
begin
    new.updated_at := now();
    new.updated_by := auth.uid();
    return new;
end;
$$ LANGUAGE plpgsql;

drop trigger if exists handle_updated_by on productions;
create trigger
    handle_updated_by before update
on productions
for each row
    execute procedure set_updated_by();


alter table "public"."productions" enable row level security;

CREATE UNIQUE INDEX productions_pkey ON public.productions USING btree (id);

alter table "public"."productions" add constraint "productions_pkey" PRIMARY KEY using index "productions_pkey";
